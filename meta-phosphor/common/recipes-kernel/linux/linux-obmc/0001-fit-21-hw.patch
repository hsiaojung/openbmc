diff --git a/arch/arm/boot/dts/aspeed-bmc-opp-palmetto.dts b/arch/arm/boot/dts/aspeed-bmc-opp-palmetto.dts
index 18df9c7..73610e5 100644
--- a/arch/arm/boot/dts/aspeed-bmc-opp-palmetto.dts
+++ b/arch/arm/boot/dts/aspeed-bmc-opp-palmetto.dts
@@ -28,7 +28,7 @@
 
 		flash_memory: region@98000000 {
 			no-map;
-			reg = <0x98000000 0x01000000>; /* 16MB */
+			reg = <0x98000000 0x04000000>; /* 64MB */
 		};
 	};
 
@@ -75,6 +75,7 @@
 	flash@0 {
 		status = "okay";
 		m25p,fast-read;
+		label = "bmc";
 #include "openbmc-flash-layout.dtsi"
 	};
 };
@@ -82,12 +83,12 @@
 &spi {
 	status = "okay";
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_spi1debug_default>;
+	pinctrl-0 = <&pinctrl_spi1_default>;
 
 	flash@0 {
 		status = "okay";
-		label = "pnor";
 		m25p,fast-read;
+		label = "pnor";
 	};
 };
 
@@ -99,54 +100,103 @@
 			&pinctrl_ddcclk_default &pinctrl_ddcdat_default>;
 };
 
+
 &mac0 {
 	status = "okay";
 
-	use-ncsi;
-	no-hw-checksum;
-
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_rmii1_default>;
+	pinctrl-0 = <&pinctrl_rgmii1_default &pinctrl_mdio1_default>;
 };
 
 
+&uart1 {
+	/* Rear RS-232 connector */
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_txd1_default
+			&pinctrl_rxd1_default
+			&pinctrl_nrts1_default
+			&pinctrl_ndtr1_default
+			&pinctrl_ndsr1_default
+			&pinctrl_ncts1_default
+			&pinctrl_ndcd1_default
+			&pinctrl_nri1_default>;
+};
+
 &uart5 {
 	status = "okay";
 };
 
+
 &i2c0 {
 	status = "okay";
 
-	eeprom@50 {
-		compatible = "atmel,24c256";
-		reg = <0x50>;
-		pagesize = <64>;
+	nct7717@48 {
+
+		compatible = "ti,tmp423";
+		reg = <0x48>;
 	};
 
-	rtc@68 {
-		compatible = "dallas,ds3231";
-		reg = <0x68>;
-		// interrupts = <GPIOF0>
+	rtc: ds1307@32 {
+		compatible = "dallas,ds1307";
+		reg = <0x32>;
 	};
+
+
 };
 
 &i2c1 {
+
 	status = "okay";
+
+    ir35221@70 {                                                                                                                                                           
+
+         compatible = "infineon,ir35221";
+
+         reg = <0x70>;
+
+    };
+ 
+    ir35221@76 {
+
+         compatible = "infineon,ir35221";
+
+         reg = <0x76>;
+
+    };
+ 
+    ir35221@78 {
+
+         compatible = "infineon,ir35221";
+
+         reg = <0x78>;
+
+    };
+
+
 };
 
 &i2c2 {
 	status = "okay";
 
-	tmp423@4c {
+ 	nct7717@48 {
+
 		compatible = "ti,tmp423";
-		reg = <0x4c>;
-	};
+ 		reg = <0x48>;
+ 	};
 };
 
 &i2c3 {
 	status = "okay";
 
-	occ-hwmon@50 {
+    nct7717@48 {
+		compatible = "ti,tmp423";
+        reg = <0x48>;
+    };  
+
+    occ-hwmon@50 {   
+
 		compatible = "ibm,p8-occ-hwmon";
 		reg = <0x50>;
 	};
@@ -154,56 +204,80 @@
 
 &i2c4 {
 	status = "okay";
+
+    nct7717@48 {
+		compatible = "ti,tmp423";
+        reg = <0x48>;
+    };  
+
 };
 
 &i2c5 {
 	status = "okay";
+
 };
 
 &i2c6 {
 	status = "okay";
+
+    occ-hwmon@51 {   
+		compatible = "ibm,p8-occ-hwmon";
+		reg = <0x51>;
+	};
 };
 
 &i2c7 {
 	status = "okay";
+
+	nct7717@48 {
+		compatible = "ti,tmp423";
+		reg = <0x48>;
+	};        
+
+
+    ir35221@73 {                                                                                                                                                           
+
+         compatible = "infineon,ir35221";
+
+         reg = <0x73>;
+
+    };
+ 
+    ir35221@76 {
+
+         compatible = "infineon,ir35221";
+
+         reg = <0x76>;
+
+    };
+ 
+    ir35221@77 {
+
+         compatible = "infineon,ir35221";
+
+         reg = <0x77>;
+
+    };
+
+
+
+
 };
 
-&gpio {
-	pin_func_mode0 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(C, 4) GPIO_ACTIVE_HIGH>;
-		output-low;
-		line-name = "func_mode0";
-	};
 
-	pin_func_mode1 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(C, 5)  GPIO_ACTIVE_HIGH>;
-		output-low;
-		line-name = "func_mode1";
-	};
+&i2c10 {
+	status = "okay";
 
-	pin_func_mode2 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(C, 6) GPIO_ACTIVE_HIGH>;
-		output-low;
-		line-name = "func_mode2";
-	};
+	nct7717@48 {
+		compatible = "ti,tmp423";
+		reg = <0x48>;
+	};        
+};
 
-	pin_gpio_a0 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(A, 0) GPIO_ACTIVE_HIGH>;
-		input;
-		line-name = "BMC_FAN_RESERVED_N";
-	};
 
-	pin_gpio_a1 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(A, 1) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "APSS_WDT_N";
-	};
+&gpio {
 
+	
 	pin_gpio_b1 {
 		gpio-hog;
 		gpios = <ASPEED_GPIO(B, 1) GPIO_ACTIVE_HIGH>;
@@ -225,47 +299,6 @@
 		line-name = "SPIVID_STBY_RESET_N";
 	};
 
-	pin_gpio_d1 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(D, 1) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "BMC_POWER_UP";
-	};
-
-	pin_gpio_f1 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(F, 1) GPIO_ACTIVE_HIGH>;
-		input;
-		line-name = "BMC_BATTERY_TEST";
-	};
-
-	pin_gpio_f4 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(F, 4) GPIO_ACTIVE_HIGH>;
-		input;
-		line-name = "AST_HW_FAULT_N";
-	};
-
-	pin_gpio_f5 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(F, 5) GPIO_ACTIVE_HIGH>;
-		input;
-		line-name = "AST_SYS_FAULT_N";
-	};
-
-	pin_gpio_f7 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(F, 7) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "BMC_FULL_SPEED_N";
-	};
-
-	pin_gpio_g3 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(G, 3) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "BMC_FAN_ERROR_N";
-	};
 
 	pin_gpio_g4 {
 		gpio-hog;
@@ -281,43 +314,36 @@
 		line-name = "BMC_WDT_RST2_P";
 	};
 
-	pin_gpio_h0 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(H, 0) GPIO_ACTIVE_HIGH>;
-		input;
-		line-name = "PE_SLOT_TEST_EN_N";
-	};
-
 	pin_gpio_h1 {
 		gpio-hog;
 		gpios = <ASPEED_GPIO(H, 1) GPIO_ACTIVE_HIGH>;
 		input;
 		line-name = "BMC_RTCRST_N";
 	};
+    pin_gpio_h2 {
+        gpio-hog;
+        gpios = <ASPEED_GPIO(H, 2) GPIO_ACTIVE_HIGH>;
+        output-high;
+        line-name = "SYS_PWROK_BMC";
+    };
 
-	pin_gpio_h2 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(H, 2) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "SYS_PWROK_BMC";
-	};
+    pin_gpio_h6 {
+        gpio-hog;
+        gpios = <ASPEED_GPIO(H, 6) GPIO_ACTIVE_HIGH>;
+        output-high;
+        line-name = "SCM1_FSI0_DATA_EN";
+    };
 
-	pin_gpio_h6 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(H, 6) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "SCM1_FSI0_DATA_EN";
-	};
+    pin_gpio_q6 {
+        gpio-hog;
+        gpios = <ASPEED_GPIO(Q, 6) GPIO_ACTIVE_HIGH>;
+        output-high;
+        line-name = "BMC_BMC5012E_RST";
+    };
 
-	pin_gpio_h7 {
-		gpio-hog;
-		gpios = <ASPEED_GPIO(H, 7) GPIO_ACTIVE_HIGH>;
-		output-high;
-		line-name = "BMC_TPM_INT_N";
-	};
 
-};
 
+};
 &vuart {
 	status = "okay";
 };
@@ -335,3 +361,64 @@
 &wdt2 {
 	status = "okay";
 };
+
+
+&pwm_tacho {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm0_default &pinctrl_pwm1_default
+		&pinctrl_pwm2_default &pinctrl_pwm3_default	&pinctrl_pwm4_default>;
+
+	fan@0 {
+		reg = <0x00>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x00>;
+	};
+
+	fan@1 {
+		reg = <0x00>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x01>;
+	};
+
+	fan@2 {
+		reg = <0x01>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x02>;
+	};
+
+	fan@3 {
+		reg = <0x01>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x03>;
+	};
+
+	fan@4 {
+		reg = <0x02>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x04>;
+	};
+
+	fan@5 {
+		reg = <0x02>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x05>;
+	};
+
+	fan@6 {
+		reg = <0x03>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x06>;
+	};
+
+	fan@7 {
+		reg = <0x03>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x07>;
+	};
+
+	fan@8 {
+		reg = <0x04>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x08>;
+	};
+
+
+	fan@9 {
+		reg = <0x04>;
+		aspeed,fan-tach-ch = /bits/ 8 <0x09>;
+	};
+
+
+};
diff --git a/arch/arm/boot/dts/aspeed-g4.dtsi b/arch/arm/boot/dts/aspeed-g4.dtsi
index b82ebef..c3c2ada 100644
--- a/arch/arm/boot/dts/aspeed-g4.dtsi
+++ b/arch/arm/boot/dts/aspeed-g4.dtsi
@@ -342,6 +342,14 @@
 				ranges = <0 0x1e78a000 0x1000>;
 			};
 
+			pwm_tacho: pwm-tacho-controller@1e786000 {
+				compatible = "aspeed,ast2400-pwm-tacho";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x1e786000 0x1000>;
+				clocks = <&pwm_tacho_fixed_clk>;
+
+			};
 
 		};
 	};
diff --git a/drivers/net/ethernet/faraday/ftgmac100.c b/drivers/net/ethernet/faraday/ftgmac100.c
index 1a4d57f..162719e 100644
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@ -21,6 +21,7 @@
 
 #define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
 
+#include <linux/clk.h>
 #include <linux/dma-mapping.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
@@ -59,6 +60,9 @@
 /* Min number of tx ring entries before stopping queue */
 #define TX_THRESHOLD		(MAX_SKB_FRAGS + 1)
 
+#define FTGMAC_100MHZ		100000000
+#define FTGMAC_25MHZ		25000000
+
 struct ftgmac100 {
 	/* Registers */
 	struct resource *res;
@@ -96,6 +100,7 @@ struct ftgmac100 {
 	struct napi_struct napi;
 	struct work_struct reset_task;
 	struct mii_bus *mii_bus;
+	struct clk *clk;
 
 	/* Link management */
 	int cur_speed;
@@ -1056,13 +1061,18 @@ static int ftgmac100_mii_probe(struct ftgmac100 *priv, phy_interface_t intf)
 {
 	struct net_device *netdev = priv->netdev;
 	struct phy_device *phydev;
+	int tmp = 0;
+
 
+ 	printk (KERN_ALERT  "Cyril debug printf \n");
+ 	printk (KERN_ALERT  "file:[%s], functaion:[%s] line:[%d] \n", __FILE__, __func__, __LINE__);
 	phydev = phy_find_first(priv->mii_bus);
 	if (!phydev) {
 		netdev_info(netdev, "%s: no PHY found\n", netdev->name);
 		return -ENODEV;
 	}
 
+ 	printk (KERN_ALERT  "file:[%s], functaion:[%s] line:[%d] \n", __FILE__, __func__, __LINE__);
 	phydev = phy_connect(netdev, phydev_name(phydev),
 			     &ftgmac100_adjust_link, intf);
 
@@ -1071,15 +1081,28 @@ static int ftgmac100_mii_probe(struct ftgmac100 *priv, phy_interface_t intf)
 		return PTR_ERR(phydev);
 	}
 
+ 	printk (KERN_ALERT  "file:[%s], functaion:[%s] line:[%d] \n", __FILE__, __func__, __LINE__);
 	/* Indicate that we support PAUSE frames (see comment in
 	 * Documentation/networking/phy.txt)
 	 */
 	phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
 	phydev->advertising = phydev->supported;
 
+ 	printk (KERN_ALERT  "file:[%s], functaion:[%s] line:[%d] \n", __FILE__, __func__, __LINE__);
 	/* Display what we found */
 	phy_attached_info(phydev);
 
+    /////  cyril.chang ??????????????????????????????????   
+    phy_write(phydev, 0x17, 0xd07);
+    tmp = phy_read(phydev, 0x15);
+    tmp |= 0x01;
+    tmp &= 0xff9f;
+    phy_write(phydev, 0x15, tmp);
+    phy_write(phydev, 0x17, 0x0);                                                                                                                                  
+    phy_write(phydev, 0x1c, 0x8c00);
+    phy_write(phydev, 0x18, 0xf0e7);
+
+ 	printk (KERN_ALERT  "file:[%s], functaion:[%s] line:[%d] \n", __FILE__, __func__, __LINE__);
 	return 0;
 }
 
@@ -1734,6 +1757,22 @@ static void ftgmac100_ncsi_handler(struct ncsi_dev *nd)
 		    nd->link_up ? "up" : "down");
 }
 
+static void ftgmac100_setup_clk(struct ftgmac100 *priv)
+{
+	priv->clk = devm_clk_get(priv->dev, NULL);
+	if (IS_ERR(priv->clk))
+		return;
+
+	clk_prepare_enable(priv->clk);
+
+	/* Aspeed specifies a 100MHz clock is required for up to
+	 * 1000Mbit link speeds. As NCSI is limited to 100Mbit, 25MHz
+	 * is sufficient
+	 */
+	clk_set_rate(priv->clk, priv->use_ncsi ? FTGMAC_25MHZ :
+			FTGMAC_100MHZ);
+}
+
 static int ftgmac100_probe(struct platform_device *pdev)
 {
 	struct resource *res;
@@ -1830,6 +1869,9 @@ static int ftgmac100_probe(struct platform_device *pdev)
 			goto err_setup_mdio;
 	}
 
+	if (priv->is_aspeed)
+		ftgmac100_setup_clk(priv);
+
 	/* Default ring sizes */
 	priv->rx_q_entries = priv->new_rx_q_entries = DEF_RX_QUEUE_ENTRIES;
 	priv->tx_q_entries = priv->new_tx_q_entries = DEF_TX_QUEUE_ENTRIES;
@@ -1873,7 +1915,7 @@ static int ftgmac100_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int __exit ftgmac100_remove(struct platform_device *pdev)
+static int ftgmac100_remove(struct platform_device *pdev)
 {
 	struct net_device *netdev;
 	struct ftgmac100 *priv;
@@ -1883,6 +1925,8 @@ static int __exit ftgmac100_remove(struct platform_device *pdev)
 
 	unregister_netdev(netdev);
 
+	clk_disable_unprepare(priv->clk);
+
 	/* There's a small chance the reset task will have been re-queued,
 	 * during stop, make sure it's gone before we free the structure.
 	 */
@@ -1906,7 +1950,7 @@ MODULE_DEVICE_TABLE(of, ftgmac100_of_match);
 
 static struct platform_driver ftgmac100_driver = {
 	.probe	= ftgmac100_probe,
-	.remove	= __exit_p(ftgmac100_remove),
+	.remove	= ftgmac100_remove,
 	.driver	= {
 		.name		= DRV_NAME,
 		.of_match_table	= ftgmac100_of_match,
